# 事件监听器未注册问题

## 问题现象

从日志中可以看到：

1. ✅ 主应用启动成功
2. ✅ `FilterConfiguration` 被创建（有 "FilterConfiguration - 创建 PluginDelegatingFilter Bean" 日志）
3. ✅ 插件启动成功（有 "Plugin activity-plugin is started" 日志）
4. ❌ **没有看到 "FilterConfiguration - 收到插件启动事件" 日志**

## 根本原因

**`@EventListener` 方法没有被 Spring 注册为事件监听器！**

### 为什么没有注册？

检查日志，发现：

```
FilterConfiguration - 创建 PluginDelegatingFilter Bean
FilterConfiguration - 注入 PluginFilterManager: config.com.gaoding.ska.plugin.activity.PluginFilterManager@7f8a9454
```

这说明 `FilterConfiguration` 的 `@Bean` 方法被调用了，但 `@EventListener` 方法没有被注册。

### 可能的原因

1. **`FilterConfiguration` 没有被注册为 Bean**
   - 只有 `@Bean` 方法被调用，但类本身没有被扫描

2. **`@EventListener` 处理器没有被初始化**
   - Spring 的 `EventListenerMethodProcessor` 没有处理 `FilterConfiguration`

## 解决方案

### 方案1：确保 FilterConfiguration 被扫描为 Bean

`FilterConfiguration` 有 `@Configuration` 注解，应该被自动扫描。但可能因为某些原因没有被扫描。

**添加调试日志**：

```java
@Configuration
@OnMainApplication
public class FilterConfiguration implements ApplicationContextAware {
    
    public FilterConfiguration() {
        System.out.println("FilterConfiguration - 构造函数被调用");
        System.out.println("FilterConfiguration - ClassLoader: " + this.getClass().getClassLoader().getClass().getName());
    }
    
    @PostConstruct
    public void init() {
        System.out.println("FilterConfiguration - @PostConstruct 初始化");
        System.out.println("FilterConfiguration - ApplicationContext: " + applicationContext);
    }
    
    // ...
}
```

### 方案2：使用 ApplicationListener 接口（推荐）

将 `@EventListener` 改为实现 `ApplicationListener` 接口：

```java
@Configuration
@OnMainApplication
public class FilterConfiguration implements ApplicationContextAware, 
                                            ApplicationListener<SbpPluginStartedEvent> {
    
    @Override
    public void onApplicationEvent(SbpPluginStartedEvent event) {
        System.out.println("=================================================");
        System.out.println("FilterConfiguration - 收到插件启动事件: " + event);
        
        // ... 原有的处理逻辑
    }
    
    // 移除 @EventListener 注解的方法
}
```

**优点**：
- ✅ 更明确，Spring 一定会注册
- ✅ 不依赖 `EventListenerMethodProcessor`
- ✅ 更容易调试

### 方案3：检查 EventListenerMethodProcessor

确保 `EventListenerMethodProcessor` 被正确初始化：

```java
@Configuration
@OnMainApplication
public class FilterConfiguration implements ApplicationContextAware {
    
    @Autowired(required = false)
    private EventListenerMethodProcessor eventListenerMethodProcessor;
    
    @PostConstruct
    public void init() {
        System.out.println("FilterConfiguration - EventListenerMethodProcessor: " + eventListenerMethodProcessor);
    }
    
    // ...
}
```

## 推荐修复

**使用 `ApplicationListener` 接口**，这是最可靠的方式：

```java
package com.gaoding.ska.plugin.config;

import org.laxture.sbp.spring.boot.SbpPluginStartedEvent;
import org.laxture.sbp.spring.boot.SbpPluginStoppedEvent;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.Filter;

@Configuration
@OnMainApplication
public class FilterConfiguration implements ApplicationContextAware,
        ApplicationListener<SbpPluginStartedEvent> {

    @Autowired
    private PluginFilterManager pluginFilterManager;

    @Autowired
    private PluginInterceptorManager pluginInterceptorManager;

    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.applicationContext = applicationContext;
    }

    /**
     * 监听插件启动事件
     * 使用 ApplicationListener 接口，确保事件监听器被正确注册
     */
    @Override
    public void onApplicationEvent(SbpPluginStartedEvent event) {
        System.out.println("=================================================");
        System.out.println("FilterConfiguration - 收到插件启动事件: " + event);

        // 打印当前执行上下文信息
        ApplicationContext currentContext = getCurrentApplicationContext();
        System.out.println("FilterConfiguration - 当前执行上下文: " + currentContext);
        System.out.println("FilterConfiguration - 当前执行上下文 ID: " + (currentContext != null ? currentContext.getId() : "null"));
        System.out.println("FilterConfiguration - 当前类加载器: " + this.getClass().getClassLoader().getClass().getName());

        System.out.println("FilterConfiguration - pluginFilterManager: " + pluginFilterManager);
        System.out.println("FilterConfiguration - pluginFilterManager hashCode: " + (pluginFilterManager != null ? pluginFilterManager.hashCode() : "null"));
        System.out.println("FilterConfiguration - pluginInterceptorManager: " + pluginInterceptorManager);
        System.out.println("FilterConfiguration - pluginInterceptorManager hashCode: " + (pluginInterceptorManager != null ? pluginInterceptorManager.hashCode() : "null"));

        // SbpPluginStartedEvent 的 source 是插件的 ApplicationContext
        Object source = event.getSource();
        System.out.println("FilterConfiguration - Event source type: " + source.getClass().getName());

        if (source instanceof ApplicationContext) {
            ApplicationContext pluginContext = (ApplicationContext) source;
            System.out.println("FilterConfiguration - 成功获取插件上下文: " + pluginContext);
            System.out.println("FilterConfiguration - 插件上下文 ID: " + pluginContext.getId());
            System.out.println("FilterConfiguration - 插件上下文 DisplayName: " + pluginContext.getDisplayName());

            // 从插件上下文获取插件 ID
            String pluginId = getPluginId(pluginContext);
            System.out.println("FilterConfiguration - 插件ID: " + pluginId);

            // 注册插件 Filter
            registerPluginFilters(pluginId, pluginContext);

            // 注册插件 Interceptor
            registerPluginInterceptors(pluginId, pluginContext);

            // 打印注册后的状态
            System.out.println("FilterConfiguration - 注册完成后，Filter 数量: " + pluginFilterManager.getFilterCount());
            System.out.println("FilterConfiguration - 注册完成后，Interceptor 数量: " + pluginInterceptorManager.getInterceptorCount());
        } else {
            System.out.println("FilterConfiguration - Event source 不是 ApplicationContext 类型");
        }
        System.out.println("=================================================");
    }

    // ... 其他方法保持不变
}
```

## 为什么 ApplicationListener 更可靠？

### @EventListener 的工作原理

```
1. Spring 启动
2. EventListenerMethodProcessor 初始化
3. 扫描所有 Bean 的方法
4. 找到 @EventListener 注解的方法
5. 注册为事件监听器
```

**可能失败的原因**：
- `EventListenerMethodProcessor` 没有被初始化
- Bean 创建时机问题
- 条件注解导致的扫描问题

### ApplicationListener 的工作原理

```
1. Spring 启动
2. 扫描所有实现 ApplicationListener 的 Bean
3. 直接注册为事件监听器
```

**优点**：
- ✅ 更直接，不依赖额外的处理器
- ✅ 更早注册，不会错过事件
- ✅ 更容易调试

## 总结

**问题**：`@EventListener` 方法没有被注册为事件监听器

**解决方案**：改用 `ApplicationListener` 接口

**优点**：
- ✅ 更可靠
- ✅ 更明确
- ✅ 更容易调试

**下一步**：修改 `FilterConfiguration`，使用 `ApplicationListener` 接口

