# 插件路由机制说明

## 概述

本文档说明 SBP (Spring Boot Plugin) 框架如何将 HTTP 请求从主应用的容器路由到插件容器的 Controller。

## 路由机制

### 1. 插件 Spring 上下文创建

当插件启动时，SBP 框架会为每个插件创建独立的 Spring 应用上下文：

```java
// ActivityPlugin.java
@Override
protected SpringBootstrap createSpringBootstrap() {
    return new SpringBootstrap(this, ActivityPluginConfiguration.class);
}
```

**关键步骤**：
1. `SpringBootstrap` 使用插件配置类（`ActivityPluginConfiguration`）创建独立的 Spring 应用上下文
2. 插件配置类通过 `@ComponentScan` 扫描插件中的组件（Controller、Service、Repository 等）
3. 插件中的 Controller 被注册到插件的 Spring 上下文中

### 2. Controller 注册到插件上下文

插件中的 Controller 通过以下方式注册：

```java
// ActivityController.java
@RestController
@RequestMapping("/api/activities")
public class ActivityController {
    // ...
}
```

**注册过程**：
1. `@ComponentScan(basePackages = "com.gaoding.ska.plugin")` 扫描插件包下的所有组件
2. `@RestController` 注解的类被识别为 Controller
3. `@RequestMapping` 注解定义请求映射路径
4. Controller 被注册到插件的 Spring 应用上下文中

### 3. 请求路由机制

SBP 框架通过以下机制实现请求路由：

#### 3.1 DispatcherServlet 路由

主应用和插件共享同一个 `DispatcherServlet`，但使用不同的 `HandlerMapping`：

- **主应用的 HandlerMapping**：处理主应用的请求
- **插件的 HandlerMapping**：处理插件的请求

#### 3.2 请求处理流程

```
HTTP 请求
    ↓
主应用的 DispatcherServlet
    ↓
遍历所有 HandlerMapping（包括主应用和所有插件的）
    ↓
匹配到插件的 HandlerMapping
    ↓
找到对应的 Controller 方法
    ↓
执行 Controller 方法
    ↓
返回响应
```

#### 3.3 插件上下文集成

SBP 框架通过以下方式将插件的 Spring 上下文集成到主应用：

1. **插件上下文注册**：
   - 插件启动时，`SpringBootstrap` 创建插件的 Spring 应用上下文
   - 插件的上下文被注册到 `SpringBootPluginManager` 中

2. **HandlerMapping 注册**：
   - 插件的 `RequestMappingHandlerMapping` 被注册到主应用的 `DispatcherServlet`
   - 主应用的 `DispatcherServlet` 会遍历所有已注册的 `HandlerMapping` 来查找匹配的处理器

3. **请求分发**：
   - 当请求到达时，`DispatcherServlet` 遍历所有 `HandlerMapping`
   - 如果插件的 `HandlerMapping` 匹配到请求路径，则使用插件的 Controller 处理请求

### 4. 关键组件

#### 4.1 SpringBootstrap

`SpringBootstrap` 负责创建插件的 Spring 应用上下文：

- 使用插件配置类初始化 Spring 上下文
- 扫描并注册插件中的组件（Controller、Service、Repository 等）
- 将插件的上下文注册到插件管理器中

#### 4.2 SpringBootPluginManager

`SpringBootPluginManager` 管理所有插件的生命周期和上下文：

- 加载和启动插件
- 管理插件的 Spring 应用上下文
- 将插件的 `HandlerMapping` 注册到主应用的 `DispatcherServlet`

#### 4.3 RequestMappingHandlerMapping

每个插件的 Spring 上下文都有自己的 `RequestMappingHandlerMapping`：

- 扫描插件中的 `@RequestMapping` 注解
- 建立请求路径到 Controller 方法的映射关系
- 被注册到主应用的 `DispatcherServlet` 中

### 5. 请求示例

假设有一个请求：`GET /api/activities`

**处理流程**：

1. 请求到达主应用的 `DispatcherServlet`
2. `DispatcherServlet` 遍历所有 `HandlerMapping`：
   - 主应用的 `HandlerMapping`：不匹配 `/api/activities`
   - 活动插件的 `HandlerMapping`：匹配到 `/api/activities` → `ActivityController.getAllActivities()`
3. 使用活动插件的 Controller 处理请求
4. 返回响应

### 6. 隔离机制

#### 6.1 上下文隔离

- 每个插件拥有独立的 Spring 应用上下文
- 插件的 Bean 不会与主应用或其他插件的 Bean 冲突
- 插件之间的依赖相互隔离

#### 6.2 类加载隔离

- 每个插件使用独立的类加载器（`PluginClassLoader`）
- 插件的类不会与主应用或其他插件的类冲突
- 支持插件使用不同版本的依赖库

### 7. Filter 和 Interceptor 的作用域

#### 7.1 Filter（过滤器）

- **主应用的 Filter**：作用于所有请求（包括插件请求）
- **插件的 Filter**：只作用于插件自己的请求
- Filter 在 Servlet 层面工作，早于 Controller 执行

#### 7.2 Interceptor（拦截器）

- **主应用的 Interceptor**：作用于主应用的请求
- **插件的 Interceptor**：作用于插件自己的请求
- Interceptor 在 Spring MVC 层面工作，需要注册到插件的 `HandlerMapping`

### 8. 注意事项

1. **URL 路径冲突**：
   - 不同插件的 Controller 路径不能冲突
   - 建议使用插件特定的路径前缀（如 `/api/activities`、`/api/users`）

2. **Filter 注册**：
   - 插件的 Filter 需要注册到插件的 Spring 上下文中
   - 使用 `FilterRegistrationBean` 可以精确控制 URL 模式

3. **拦截器注册**：
   - 插件的 Interceptor 需要注册到插件的 `WebMvcConfigurer` 中
   - 在插件环境中，`WebMvcConfigurer` 可能不会自动生效，建议使用 Filter

4. **上下文访问**：
   - 插件无法直接访问主应用的 Bean
   - 主应用无法直接访问插件的 Bean
   - 需要通过扩展点机制进行通信

## 总结

SBP 框架通过以下机制实现请求路由：

1. **独立的 Spring 上下文**：每个插件拥有独立的 Spring 应用上下文
2. **HandlerMapping 注册**：插件的 `RequestMappingHandlerMapping` 被注册到主应用的 `DispatcherServlet`
3. **请求分发**：`DispatcherServlet` 遍历所有 `HandlerMapping` 来查找匹配的处理器
4. **隔离机制**：通过独立的上下文和类加载器实现插件间的隔离

这种设计使得插件可以独立开发和部署，同时与主应用无缝集成。

